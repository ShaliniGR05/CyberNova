<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNS Traffic Monitor</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåê DNS Traffic Monitor</h1>
            <p>Real-time monitoring of DNS queries and responses</p>
            
            <div class="controls">
                <button id="startBtn" class="btn btn-success">Start Monitoring</button>
                <button id="stopBtn" class="btn btn-danger" disabled>Stop Monitoring</button>
                <button id="clearBtn" class="btn btn-warning">Clear Events</button>
                <span class="status" id="status">Stopped</span>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="eventCount">0</div>
                <div class="stat-label">Total Events</div>
            </div>
            <div class="stat-item info">
                <div class="stat-value" id="queryCount">0</div>
                <div class="stat-label">DNS Queries</div>
            </div>
            <div class="stat-item success">
                <div class="stat-value" id="responseCount">0</div>
                <div class="stat-label">DNS Responses</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="uniqueDomains">0</div>
                <div class="stat-label">Unique Domains</div>
            </div>
        </div>
        
        <div class="table-container">
            <table id="eventsTable">
                <thead>
                    <tr>
                        <th>Timestamp</th>
                        <th>Direction</th>
                        <th>Query Name</th>
                        <th>Query Type</th>
                        <th>Source IP</th>
                        <th>Destination IP</th>
                        <th>Response Code</th>
                        <th>Answer Count</th>
                        <th>Answers</th>
                    </tr>
                </thead>
                <tbody id="eventsBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let isMonitoring = false;
        let eventCounts = {total: 0, queries: 0, responses: 0};
        let uniqueDomains = new Set();
        
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const clearBtn = document.getElementById('clearBtn');
        const statusEl = document.getElementById('status');
        const eventsBody = document.getElementById('eventsBody');
        
        startBtn.addEventListener('click', startMonitoring);
        stopBtn.addEventListener('click', stopMonitoring);
        clearBtn.addEventListener('click', clearEvents);
        
        async function startMonitoring() {
            try {
                const response = await fetch('/api/start');
                const data = await response.json();
                
                if (data.status === 'started' || data.status === 'already running') {
                    isMonitoring = true;
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    statusEl.textContent = 'Monitoring';
                    statusEl.className = 'status status-active';
                    
                    pollEvents();
                }
            } catch (error) {
                console.error('Error starting monitoring:', error);
            }
        }
        
        async function stopMonitoring() {
            try {
                const response = await fetch('/api/stop');
                const data = await response.json();
                
                isMonitoring = false;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                statusEl.textContent = 'Stopped';
                statusEl.className = 'status';
            } catch (error) {
                console.error('Error stopping monitoring:', error);
            }
        }
        
        async function clearEvents() {
            try {
                await fetch('/api/clear');
                eventsBody.innerHTML = '';
                eventCounts = {total: 0, queries: 0, responses: 0};
                uniqueDomains.clear();
                updateStats();
            } catch (error) {
                console.error('Error clearing events:', error);
            }
        }
        
        async function pollEvents() {
            while (isMonitoring) {
                try {
                    const response = await fetch('/api/events');
                    const events = await response.json();
                    
                    displayEvents(events);
                    updateStats();
                    
                    await new Promise(resolve => setTimeout(resolve, 2000));
                } catch (error) {
                    console.error('Error polling events:', error);
                    await new Promise(resolve => setTimeout(resolve, 5000));
                }
            }
        }
        
        function displayEvents(events) {
            eventsBody.innerHTML = '';
            eventCounts = {total: 0, queries: 0, responses: 0};
            uniqueDomains.clear();
            
            events.forEach(event => {
                if (event.error) {
                    // Handle error events
                    const row = document.createElement('tr');
                    row.className = 'row-error';
                    row.innerHTML = `
                        <td colspan="9" class="error-cell">Error: ${event.error}</td>
                    `;
                    eventsBody.appendChild(row);
                    return;
                }
                
                eventCounts.total++;
                
                if (event.direction === 'Query') {
                    eventCounts.queries++;
                } else if (event.direction === 'Response') {
                    eventCounts.responses++;
                }
                
                if (event.query_name && event.query_name !== '<none>') {
                    const domain = event.query_name.replace(/\.$/, ''); // Remove trailing dot
                    uniqueDomains.add(domain.toLowerCase());
                }
                
                const row = document.createElement('tr');
                row.className = event.direction === 'Query' ? 'row-info' : 'row-success';
                
                const answers = event.answers ? 
                    event.answers.map(a => `${a.name} (${a.type}): ${a.data}`).join('; ') : '-';
                
                row.innerHTML = `
                    <td>${new Date(event.timestamp).toLocaleString()}</td>
                    <td><span class="direction-badge ${event.direction.toLowerCase()}">${event.direction}</span></td>
                    <td class="domain-cell" title="${event.query_name}">${truncateText(event.query_name, 30)}</td>
                    <td>${event.query_type || '-'}</td>
                    <td>${event.source_ip}</td>
                    <td>${event.dest_ip}</td>
                    <td>${event.response_code || '-'}</td>
                    <td>${event.answer_count || 0}</td>
                    <td class="answers-cell" title="${answers}">${truncateText(answers, 40)}</td>
                `;
                
                eventsBody.appendChild(row);
            });
        }
        
        function updateStats() {
            document.getElementById('eventCount').textContent = eventCounts.total;
            document.getElementById('queryCount').textContent = eventCounts.queries;
            document.getElementById('responseCount').textContent = eventCounts.responses;
            document.getElementById('uniqueDomains').textContent = uniqueDomains.size;
        }
        
        function truncateText(text, maxLength) {
            if (!text || text === '-') return text;
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
        }
    </script>
</body>
</html>
